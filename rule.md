# Node.js下《俄罗斯方块99》游戏代码编写说明

## 一、项目结构建议

建议以模块化结构组织代码，可以采用如下目录层级：

- `/src`
    - `TetrisBoard.js`     // 单个俄罗斯方块棋盘及方块、消行逻辑
    - `PlayerController.js` // 玩家输入、目标策略
    - `GameManager.js`      // 主控制器，管理所有玩家、游戏规则
    - `GarbageManager.js`   // 攻击、抵消及垃圾行发送机制
    - `utils/`              // 通用工具（如随机数、旋转数据等）
    - `config/`             // 攻击表、徽章倍率、旋转参数等全局配置
    - `index.js`            // 程序入口

---

## 二、各核心类详细说明

### 1. TetrisBoard

*职责*：独立移动/旋转方块、行消除、棋盘状态维护

#### 主要属性
- `grid`: 20x10的二维数组表示场地。
- `currentPiece`: 正在操作的方块对象（含类型、位置、旋转态）。
- `holdPiece`: 暂存方块。
- `nextPieces`: 6个预览方块队列，根据7-Bag机制生成。
- `garbageBuffer`: 接收到的垃圾行缓冲池，数组结构。
- `lockDelayCounter`: 当前方块触地后的延时计数。
- `comboCounter`: 连击计数（Ren）。
- `b2bFlag`: 是否处于Back-to-Back状态。
- `badgeCount`: 当前拥有徽章数。
- `koFlag`: 本回合是否造成击杀。

#### 主要方法与细节
- **方块生成**：实现7-Bag，每生成7个时刷新匿名数组，并依次取用。
- **方块旋转和踢墙**：采用SRS标准及wall kick表，特别注意T-spin判定和踢墙逻辑。
- **Hold机制**：允许每回合一次交换；临时保存并刷新`currentPiece`。
- **Ghost Piece显示**：计算当前方块理论落定位置，用于前端展现。
- **锁定延迟**：落地后记录时间，支持移动/旋转重置延时，需设定最大重置次数。
- **消除判定**：判断需要消除的行，记录消除类型（如T-Spin、Tetris等），触发连击/B2B判定。
- **垃圾行上涨**：根据`garbageBuffer`内容及抵消结果，将垃圾行从底部推入网格，并随机确定缺口。

---

### 2. PlayerController

*职责*：管理玩家输入与目标策略（如方向、攻击对象选择）

#### 主要属性
- `board`: 持有一个`TetrisBoard`实例。
- `targetingMode`: 目标选择策略（Random/Attackers/Badges/KOs），枚举值定义。
- `currentTargets`: 当前已锁定的对象ID数组。
- `userInputQueue`: 玩家操作输入队列，可用于重现或AI模拟。

#### 主要方法与细节
- **输入处理**：翻译键盘或接口指令为方块操作及目标切换。
- **目标锁定**：依据当前策略和实时场上情况，动态计算`currentTargets`。
- **反击机制**：统计有多少玩家瞄准自己，更新反击加成。
- **状态同步**：与`GameManager`同步自身状态（如消除、垃圾发动、徽章变化）。

---

### 3. GameManager

*职责*：全局管理（99位玩家棋盘），调度攻击、徽章、淘汰、排名更新等

#### 主要属性
- `players`: 99个`PlayerController`数组或映射。
- `garbageQueues`: 每个玩家收到的攻击垃圾缓冲队列。
- `alivePlayers`: 当前剩余玩家集合。
- `rankings`: 玩家淘汰顺序，实时排序。
- `gravityLevel`: 当前游戏重力参数。
- `marginTimeFlag`: 是否进入缩圈/加速阶段。

#### 主要方法与细节
- **攻击分配**：轮询玩家消除结果，计算并分发垃圾行至目标玩家（委托GarbageManager计算）。
- **目标切换**：收集每个玩家当前策略，实时分配攻击目标。
- **徽章结算**：淘汰时执行徽章转移机制，发放基础徽章。
- **重力调度**：动态提高全员方块下落速度，前10强激活最高重力。
- **游戏进程管理**：倒计时、Margin Time触发与缩圈警告，终局判定。

---

### 4. GarbageManager

*职责*：专门处理攻击力计算、抵消、垃圾行生成及缓冲池管理

#### 主要属性
- `baseAttackTable`: 对应消除类型转攻击行数的表
- `comboAttackTable`: 连击加成表（映射连击数至额外攻击）
- `b2bBonus`: B2B奖励参数
- `badgeMultiplierTable`: 徽章等级对应倍率表
- `targetingBonusTable`: 反击加成表
- 其他垃圾行随机生成工具等

#### 主要方法与细节
- **攻击力计算**：接收消除、Combo、B2B、反击对象数，输出总攻击力（未乘徽章）。
- **抵消与垃圾发放**：消除时优先抵消缓冲池，若有剩余则垃圾进入对手缓冲池。
- **垃圾行生成**：依据攻击力生成对应垃圾行，缺口随机或对齐处理。
- **垃圾消耗时机**：若玩家落定未消行，则立即提升缓冲池行。
- **徽章倍率应用**：对最终攻击数乘以当前徽章倍率，返回整数行值。

---

## 三、主要数据流与通信说明

1. **消除判定**（在TetrisBoard）：每次方块落定后，判断消除类型，记录连击与B2B触发。
2. **攻击计算**（调用GarbageManager）：传入消除类型、Combo计数、B2B状态、被瞄准玩家数，返回攻击行数。
3. **缓冲池抵消**（TetrisBoard与GarbageManager协作）：消除时优先抵消收到的垃圾，剩余才向对手发垃圾。
4. **目标分配**（GameManager与PlayerController协作）：按玩家目标策略，分发攻击垃圾及判定反击加成。
5. **徽章管理**（GameManager）：玩家淘汰时结算徽章，胜者获得所有，加成倍率实时更新攻击力表。
6. **重力与游戏节奏**（GameManager）：随着玩家人数变化，更新gravityLevel供所有TetrisBoard下落参数参考。
7. **缩圈/Margin Time**：定时触发垃圾上涨加速，全局广播，并进入终局倒计时。

---

## 四、附加说明

- 建议所有主要事件（消除、攻击、徽章获取、淘汰）通过事件总线或观察者模式进行解耦，便于多玩家并发逻辑以及状态同步。
- 由于Node.js为单线程IO，可以通过`setInterval`或`setTimeout`统一驱动游戏时间步进和方块重力计算。
- 对于垃圾行随机缺口，请在GarbageManager中集中处理，设定缺口分布概率和连续对齐的几率。
- 推荐所有方块移动、消除及攻击等运算数据可通过JSON接口序列化，便于日后接入前端或AI测试。
- 对于T-Spin判定及SRS踢墙，请优先实现标准流程并注重测试细节。
